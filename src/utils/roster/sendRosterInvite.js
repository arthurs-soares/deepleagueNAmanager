const { ActionRowBuilder, ButtonBuilder, ButtonStyle, MessageFlags } = require('discord.js');
const { ContainerBuilder, TextDisplayBuilder, SeparatorBuilder } = require('@discordjs/builders');
const { colors, emojis } = require('../../config/botConfig');
const { getGuildTransitionStatus, formatRemaining } = require('../rate-limiting/guildTransitionCooldown');
const { sendDmOrFallback } = require('../dm/dmFallback');
const { getUserGuildInfo } = require('../guilds/userGuildInfo');
const { logGuildInvite } = require('../guilds/activityLogger');

/**
 * Send a DM roster invitation to a user with Accept/Decline buttons.
 * The same mechanism supports main and sub roster by encoding the roster in the customId.
 *
 * @param {import('discord.js').Client} client - Discord client
 * @param {string} targetUserId - Discord user ID to invite
 * @param {object} guildDoc - Guild document (Mongo) containing at least _id and name
 * @param {'main'|'sub'} roster - Roster type to invite the user to
 * @param {{ id: string, username?: string, tag?: string }} inviter - The user who initiated the invite
 * @returns {Promise<{ok:boolean, error?:string}>}
 */
async function sendRosterInvite(client, targetUserId, guildDoc, roster, inviter) {
  try {
    // Check if user is already a member of any guild (prevent cross-guild membership)
    if (guildDoc?.discordGuildId) {
      const { guild: existingGuild } = await getUserGuildInfo(guildDoc.discordGuildId, targetUserId);
      if (existingGuild && String(existingGuild._id) !== String(guildDoc._id)) {
        return { ok: false, error: `User is already a member of guild "${existingGuild.name}". Users can only be in one guild at a time.` };
      }
    }

    // Pre-validate before any DM: prevent invalid invitations
    const field = roster === 'main' ? 'mainRoster' : 'subRoster';
    const list = Array.isArray(guildDoc?.[field]) ? guildDoc[field] : [];

    if (list.includes(targetUserId)) {
      return { ok: false, error: 'User is already in this roster.' };
    }
    if (list.length >= 5) {
      return { ok: false, error: 'Limit of 5 users per roster reached.' };
    }

    // Cooldown pre-check: only block if trying to join a different guild
    if (guildDoc?.discordGuildId) {
      try {
        const { active, remainingMs, lastLeftGuildId } = await getGuildTransitionStatus(
          guildDoc.discordGuildId,
          targetUserId
        );
        if (active && String(guildDoc._id) !== String(lastLeftGuildId)) {
          const remaining = formatRemaining(remainingMs);
          return { ok: false, error: `That user is on a guild transition cooldown. Please wait ${remaining} before they can join another guild.` };
        }
      } catch (_) { /* ignore pre-check errors */ }
    }

    const user = await client.users.fetch(targetUserId).catch(() => null);
    if (!user) return { ok: false, error: 'Target user not found.' };
    const rosterLabel = roster === 'main' ? 'Main Roster' : 'Sub Roster';

    const container = new ContainerBuilder();

    // Convert color to integer if it's a hex string
    const primaryColor = typeof colors.primary === 'string'
      ? parseInt(colors.primary.replace('#', ''), 16)
      : colors.primary;
    container.setAccentColor(primaryColor);

    const titleText = new TextDisplayBuilder()
      .setContent(`# ${emojis.members || 'ðŸ‘¥'} Guild Roster Invitation\n\nYou have been invited to join the ${rosterLabel} of guild "${guildDoc?.name || 'Unknown'}".\n\nWould you like to join?`);

    const detailsText = new TextDisplayBuilder()
      .setContent(
        `**Guild:** ${guildDoc?.name || 'Unknown'}\n` +
        `**Roster:** ${rosterLabel}\n` +
        `**Invited by:** ${inviter?.username ? `${inviter.username}` : `<@${inviter?.id}>`}`
      );

    const footerText = new TextDisplayBuilder()
      .setContent('*This invite was generated by the server bot. If you did not expect it, you can safely decline.*');

    const timestampText = new TextDisplayBuilder()
      .setContent(`*<t:${Math.floor(Date.now() / 1000)}:R>*`);

    container.addTextDisplayComponents(titleText);
    container.addSeparatorComponents(new SeparatorBuilder());
    container.addTextDisplayComponents(detailsText);
    container.addTextDisplayComponents(footerText);
    container.addTextDisplayComponents(timestampText);

    const accept = new ButtonBuilder()
      .setCustomId(`rosterInvite:accept:${guildDoc._id}:${roster}:${inviter?.id || 'unknown'}`)
      .setLabel('Join Guild')
      .setStyle(ButtonStyle.Success);

    const decline = new ButtonBuilder()
      .setCustomId(`rosterInvite:decline:${guildDoc._id}:${roster}`)
      .setLabel("Don't Join")
      .setStyle(ButtonStyle.Secondary);

    const row = new ActionRowBuilder().addComponents(accept, decline);

    // Try DM first, fallback to private thread in dm-warning channel if DMs are disabled
    const title = `Roster Invitation â€” ${guildDoc?.name || 'Guild'}`;
    const result = await sendDmOrFallback(
      client,
      guildDoc?.discordGuildId,
      targetUserId,
      {
        components: [container, row],
        flags: MessageFlags.IsComponentsV2
      },
      {
        threadTitle: title,
        reason: `Roster invite fallback for user ${targetUserId}`,
        mentionSupportRoles: true,
        includeSupportCloseButton: true
      }
    );

    if (!result.ok) return { ok: false, error: 'Could not deliver the invitation.' };

    // Log guild invite activity
    try {
      const inviterUsername = inviter?.username || inviter?.tag || inviter?.id;
      const inviteeUsername = user?.username || user?.tag || targetUserId;
      await logGuildInvite(
        guildDoc.discordGuildId,
        String(guildDoc._id),
        guildDoc.name,
        inviter?.id,
        inviterUsername,
        targetUserId,
        inviteeUsername,
        roster
      );
    } catch (_) {}

    return { ok: true };
  } catch (error) {
    return { ok: false, error: 'Internal error while sending the invite.' };
  }
}

module.exports = { sendRosterInvite };


